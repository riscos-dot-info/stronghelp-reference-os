Software Vectors Rules
#Parent Vector_index
If you write a routine that uses a vector, it must obey the same entry and exit conditions as the corresponding RISC OS routine. For example, a routine on WrchV must preserve all registers, just as the SWI <OS_WriteC> does!

The processor mode in which your routine is entered depends on:
è	Routines vectored through <IrqV=>Vector_IrqV> (Vector &02) are always executed in IRQ mode.
è	Routines vectored through <EventV=>Vector_EventV>, <InsV=>Vector_InsV>, <RemV=>Vector_RemV>, <CnpV=>Vector_CnpV> (Vectors &10 to &16) and <TickerV=>Vector_TickerV> (&1C) are generally executed in IRQ mode, but may be executed in SVC mode if called using <OS_CallAVector>, and in certain unspecified circumstances.
è	all other routines are executed in SVC mode.

You have to be careful when calling a SWI. Whether entered in SVC or IRQ mode you *must* save R14_svc before calling any SWI, and restore it afterwards to avoid corrupting either your own return address (you were entered in SVC mode) or R14_svc of an interrupted SWI call. Additional restrictions on SWIs exist for vectors executed in IRQ mode - see <OS_ClaimDeviceVector> for details of writing interrupt code.

Errors are reported with returning the V flag set, and storing an error pointer in R0. The routine must therefore not pass on the call, as R0 has been changed! Please note that this can't be done with all vectors, some of them (those involving IRQ calls in particular) have nowhere to send the error to...


For returning from a vectored routine, there are two methods:
è	Passing on the call	:	Return by {fCode}MOV PC,R14{f} to the previous owner, ensuring you preserve the V and the C flags.
è	Intercepting the call	:	You should pull an exit address (which has been set by RISC OS) from the stack with {fCode}LDMFD R13!,\{PC}{f} with the exit flags as per the appropriate SWI definition.
